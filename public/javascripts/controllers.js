// Generated by CoffeeScript 1.3.3
(function() {
  var findHashtags, findPosition, isHash, module, replaceAllTags, tokenize;

  window.ScrumCtrl = function($scope, $location, $http) {
    var toRemove;
    $scope.newProjectForm = false;
    $scope.newTaskForm = false;
    $scope.newTaskText = "";
    $scope.todos = [];
    $scope.inprogress = [];
    $scope.dones = [];
    $scope.exists = true;
    $scope.newProjectName = "";
    $scope.newProjectEmptyName = false;
    $scope.newProjectLoading = false;
    $scope.projectName = "";
    $scope.hashFilter = "";
    $scope.ispersonal = false;
    $scope.projects = [];
    $scope.projectCreated = false;
    $scope.projectHash = "";
    toRemove = new Array();
    $http.get('info.json').success(function(data) {
      $scope.exists = data.Exists;
      return $scope.projectName = data.name;
    });
    $http.get('todo.json').success(function(data) {
      var item, _i, _len;
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        item.tokens = tokenize(item.name);
      }
      return $scope.todos = data;
    });
    $http.get('inprogress.json').success(function(data) {
      var item, _i, _len;
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        item.tokens = tokenize(item.name);
      }
      return $scope.inprogress = data;
    });
    $http.get('done.json').success(function(data) {
      var item, _i, _len;
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        item = data[_i];
        item.tokens = tokenize(item.name);
      }
      return $scope.dones = data;
    });
    $http.get('projects.json').success(function(data) {
      return $scope.projects = data;
    });
    $scope.newProject = function() {
      return $scope.newProjectForm = true;
    };
    $scope.newPersonalProject = function() {
      $scope.newProjectForm = true;
      return $scope.ispersonal = true;
    };
    $scope.cancelNewProject = function() {
      $scope.newProjectForm = false;
      return $scope.ispersonal = false;
    };
    $scope.newTask = function() {
      var pos;
      $scope.newTaskForm = true;
      pos = findPosition(document.getElementById('new-task'));
      window.scrollTo(pos[0], pos[1]);
      return setTimeout(function() {
        return document.getElementById('new-task-textarea').focus();
      }, 1);
    };
    $scope.cancelNewTask = function() {
      return $scope.newTaskForm = false;
    };
    $scope.addTask = function() {
      if ($scope.newTaskText) {
        $http.post('save', {
          name: $scope.newTaskText
        }).success(function(data) {
          var tokens;
          tokens = tokenize(data.name);
          return $scope.todos.push({
            name: data.name,
            _id: data.id,
            tokens: tokens
          });
        });
      }
      $scope.newTaskText = "";
      return $scope.newTaskForm = false;
    };
    $scope.makeInProgress = function(task) {
      if ($scope.inprogress.indexOf(task) === -1) {
        if ($scope.todos.indexOf(task) > -1) {
          $scope.todos.splice($scope.todos.indexOf(task), 1);
        }
        if ($scope.dones.indexOf(task) > -1) {
          $scope.dones.splice($scope.dones.indexOf(task), 1);
        }
        $scope.inprogress.push(task);
        return $http.post('makeInProgress', {
          id: task._id
        });
      }
    };
    $scope.makeDone = function(task) {
      if ($scope.dones.indexOf(task) === -1) {
        if ($scope.todos.indexOf(task) > -1) {
          $scope.todos.splice($scope.todos.indexOf(task), 1);
        }
        if ($scope.inprogress.indexOf(task) > -1) {
          $scope.inprogress.splice($scope.inprogress.indexOf(task), 1);
        }
        $scope.dones.push(task);
        return $http.post('makeDone', {
          id: task._id
        });
      }
    };
    $scope.makeTodo = function(task) {
      if ($scope.todos.indexOf(task) === -1) {
        if ($scope.dones.indexOf(task) > -1) {
          $scope.dones.splice($scope.dones.indexOf(task), 1);
        }
        if ($scope.inprogress.indexOf(task) > -1) {
          $scope.inprogress.splice($scope.inprogress.indexOf(task), 1);
        }
        $scope.todos.push(task);
        return $http.post('makeTodo', {
          id: task._id
        });
      }
    };
    $scope.removeTask = function(task) {
      task.isRemoved = true;
      $http.post('remove', {
        id: task._id
      });
      return setTimeout(function() {
        angular.forEach($scope.todos, function(item) {
          var index;
          if (item.isRemoved) {
            index = $scope.todos.indexOf(item);
            if (index > -1) {
              return $scope.todos.splice(index, 1);
            }
          }
        });
        angular.forEach($scope.inprogress, function(item) {
          var index;
          if (item.isRemoved) {
            index = $scope.inprogress.indexOf(item);
            if (index > -1) {
              return $scope.inprogress.splice(index, 1);
            }
          }
        });
        angular.forEach($scope.dones, function(item) {
          var index;
          if (item.isRemoved) {
            index = $scope.dones.indexOf(item);
            if (index > -1) {
              return $scope.dones.splice(index, 1);
            }
          }
        });
        return $scope.$digest();
      }, 300);
    };
    $scope.updateTaskSave = function(task) {
      task.editing = false;
      task.tokens = tokenize(task.name);
      return $http.post('update', {
        id: task._id,
        name: task.name
      });
    };
    $scope.updateTask = function(task) {
      task.editing = true;
      return setTimeout(function() {
        var cH, sH, textarea, textareas, _i, _len, _results;
        textareas = document.getElementsByTagName("textarea");
        _results = [];
        for (_i = 0, _len = textareas.length; _i < _len; _i++) {
          textarea = textareas[_i];
          sH = textarea.scrollHeight;
          cH = textarea.offsetHeight;
          if (sH > 0 && cH > 0) {
            _results.push(textarea.style.height = sH + 'px');
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      }, 1);
    };
    $scope.cancelEditing = function(task) {
      return task.editing = false;
    };
    $scope.transfered = {};
    $scope.transfer = function(task) {
      return $scope.transfered = task;
    };
    $scope.dropProgress = function() {
      return $scope.makeInProgress($scope.transfered);
    };
    $scope.dropTodo = function() {
      return $scope.makeTodo($scope.transfered);
    };
    $scope.dropDone = function() {
      return $scope.makeDone($scope.transfered);
    };
    $scope.createNewProject = function() {
      if ($scope.newProjectName === '') {
        return $scope.newProjectEmptyName = true;
      } else {
        $scope.newProjectLoading = true;
        return $http.post('create-project', {
          name: $scope.newProjectName,
          ispersonal: $scope.ispersonal
        }).success(function(data) {
          $scope.newProjectLoading = false;
          $scope.projectName = $scope.newProjectName;
          $scope.projectCreated = true;
          return $scope.projectHash = data.hash;
        });
      }
    };
    $scope.filterByHash = function(hash) {
      $scope.hashFilter = hash;
      $http.get('' + hash.replace(/\#/g, '') + '/todo.json').success(function(data) {
        var item, _i, _len;
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          item.tokens = tokenize(item.name);
        }
        return $scope.todos = data;
      });
      $http.get('' + hash.replace(/\#/g, '') + '/inprogress.json').success(function(data) {
        var item, _i, _len;
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          item.tokens = tokenize(item.name);
        }
        return $scope.inprogress = data;
      });
      return $http.get('' + hash.replace(/\#/g, '') + '/done.json').success(function(data) {
        var item, _i, _len;
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          item.tokens = tokenize(item.name);
        }
        return $scope.dones = data;
      });
    };
    $scope.removeTagFilter = function() {
      $scope.hashFilter = '';
      $http.get('todo.json').success(function(data) {
        var item, _i, _len;
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          item.tokens = tokenize(item.name);
        }
        return $scope.todos = data;
      });
      $http.get('inprogress.json').success(function(data) {
        var item, _i, _len;
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          item.tokens = tokenize(item.name);
        }
        return $scope.inprogress = data;
      });
      return $http.get('done.json').success(function(data) {
        var item, _i, _len;
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          item = data[_i];
          item.tokens = tokenize(item.name);
        }
        return $scope.dones = data;
      });
    };
    return $scope.toggleProjectState = function() {
      return $scope.ispersonal = !$scope.ispersonal;
    };
  };

  module = angular.module('scrumModule', []);

  module.directive('drag', function() {
    return {
      link: function(scope, element, attrs) {
        return element.bind('dragstart', function() {
          return scope.$apply(attrs.drag);
        });
      }
    };
  });

  module.directive('drop', function() {
    return {
      link: function(scope, element, attrs) {
        return element.bind('drop', function() {
          return scope.$apply(attrs.drop);
        });
      }
    };
  });

  window.allowDrop = function(ev) {
    return ev.preventDefault();
  };

  window.drag = function(ev) {
    return ev.dataTransfer.setData('Text', ev.target.id);
  };

  findPosition = function(obj) {
    var curleft, curtop;
    curleft = curtop = 0;
    if (obj.offsetParent) {
      curleft = obj.offsetLeft;
      curtop = obj.offsetTop;
      while (obj = obj.offsetParent) {
        curleft += obj.offsetLeft;
        curtop += obj.offsetTop;
      }
    }
    return [curleft, curtop];
  };

  findHashtags = function(txt) {
    return txt.match(/(#[A-Za-z0-9\-\_]+)/g) || [];
  };

  isHash = function(txt) {
    return findHashtags(txt).length > 0;
  };

  replaceAllTags = function(tags, txt) {
    var tag, _i, _len;
    for (_i = 0, _len = tags.length; _i < _len; _i++) {
      tag = tags[_i];
      txt = txt.replaceAll(tag, '<a href="" ng-click="filterByTag()">' + tag + '</a>');
    }
    return txt;
  };

  tokenize = function(data) {
    var token, tokens, tokensValues, _i, _len;
    tokensValues = data.replace(/\n/g, ' ').split(' ');
    tokens = [];
    for (_i = 0, _len = tokensValues.length; _i < _len; _i++) {
      token = tokensValues[_i];
      tokens.push({
        value: token,
        isHash: isHash(token)
      });
    }
    return tokens;
  };

  String.prototype.replaceAll = function(stringToFind, stringToReplace) {
    return this.split(stringToFind).join(stringToReplace);
  };

}).call(this);
